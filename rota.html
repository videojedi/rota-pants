<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xrota</title>
    <style>
        :root {
            --bg-color: #f5f5f5;
            --card-bg: #fff;
            --text-color: #333;
            --text-muted: #666;
            --border-color: #ddd;
            --header-bg: #34495e;
            --weekend-bg: #8e44ad;
            --input-bg: #fff;
            --staff-row-bg: #ecf0f1;
        }
        
        [data-theme="dark"] {
            --bg-color: #1a1a2e;
            --card-bg: #16213e;
            --text-color: #eee;
            --text-muted: #aaa;
            --border-color: #2a3f5f;
            --header-bg: #0f3460;
            --weekend-bg: #5b2c6f;
            --input-bg: #1a1a2e;
            --staff-row-bg: #0f3460;
            
            /* Dark mode shift colours */
            --early-bg: #1e5631;
            --early-text: #a8e6cf;
            --late-bg: #1a3a5c;
            --late-text: #a8d4f0;
            --mid-bg: #5c4a1e;
            --mid-text: #f0e6a8;
            --long-bg: #5c1e1e;
            --long-text: #f0a8a8;
            --split-bg: #3d1e5c;
            --split-text: #d4a8f0;
            --off-bg: #2a2a3e;
            --off-text: #888;
        }
        
        :root {
            --early-bg: #d4edda;
            --early-text: #155724;
            --late-bg: #cce5ff;
            --late-text: #004085;
            --mid-bg: #fff3cd;
            --mid-text: #856404;
            --long-bg: #f8d7da;
            --long-text: #721c24;
            --split-bg: #e2d5f1;
            --split-text: #4a235a;
            --off-bg: #f5f5f5;
            --off-text: #666;
        }
        
        * {
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        body {
            margin: 0;
            padding: 20px;
            background: var(--bg-color);
            color: var(--text-color);
            transition: background 0.3s, color 0.3s;
        }
        h1 {
            text-align: center;
            color: var(--text-color);
        }
        .info-bar {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .info-item {
            text-align: center;
        }
        .info-item label {
            font-size: 12px;
            color: var(--text-muted);
            display: block;
        }
        .info-item span {
            font-size: 18px;
            font-weight: bold;
            color: var(--text-color);
        }
        .info-item span.warning { color: #e67e22; }
        .info-item span.error { color: #e74c3c; }
        .info-item span.success { color: #27ae60; }
        
        .controls {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls h3 {
            margin-top: 0;
        }
        .shift-templates {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .shift-btn {
            padding: 8px 16px;
            border: 2px solid #3498db;
            background: var(--card-bg);
            color: #3498db;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        .shift-btn:hover {
            background: #3498db;
            color: #fff;
        }
        .shift-btn.selected {
            background: #3498db;
            color: #fff;
        }
        .shift-btn.off {
            border-color: #95a5a6;
            color: #95a5a6;
        }
        .shift-btn.off:hover, .shift-btn.off.selected {
            background: #95a5a6;
            color: #fff;
        }
        
        .action-btns {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .action-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        .action-btn.primary {
            background: #27ae60;
            color: #fff;
        }
        .action-btn.primary:hover {
            background: #219a52;
        }
        .action-btn.secondary {
            background: #3498db;
            color: #fff;
        }
        .action-btn.secondary:hover {
            background: #2980b9;
        }
        .action-btn.danger {
            background: #e74c3c;
            color: #fff;
        }
        .action-btn.danger:hover {
            background: #c0392b;
        }
        .action-btn.print {
            background: #9b59b6;
            color: #fff;
        }
        .action-btn.print:hover {
            background: #8e44ad;
        }
        
        /* Print styles */
        @media print {
            :root, [data-theme="dark"] {
                --bg-color: #fff;
                --card-bg: #fff;
                --text-color: #333;
                --text-muted: #666;
                --border-color: #ddd;
                --header-bg: #34495e;
                --weekend-bg: #8e44ad;
                --input-bg: #fff;
                --staff-row-bg: #ecf0f1;
                --early-bg: #d4edda;
                --early-text: #155724;
                --late-bg: #cce5ff;
                --late-text: #004085;
                --mid-bg: #fff3cd;
                --mid-text: #856404;
                --long-bg: #f8d7da;
                --long-text: #721c24;
                --split-bg: #e2d5f1;
                --split-text: #4a235a;
                --off-bg: #f5f5f5;
                --off-text: #666;
            }
            body {
                background: #fff;
                padding: 0;
                margin: 0;
                color: #333;
            }
            .controls, .legend, .info-bar, .week-selector, footer, .weekend-stats {
                display: none !important;
            }
            .coverage-detail {
                display: none !important;
            }
            .coverage-detail.print-visible {
                display: block !important;
                margin-top: 10px;
                background: #fff;
                padding: 5px;
                page-break-inside: avoid;
            }
            .coverage-detail.print-visible h4 {
                font-size: 12px;
                margin-bottom: 5px;
            }
            .coverage-detail.print-visible #coverageGraph {
                gap: 3px !important;
            }
            .coverage-detail.print-visible .graph-area {
                height: 50px !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            .coverage-detail.print-visible .graph-area div {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            .coverage-detail.print-visible .graph-legend span span {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            .coverage-detail.print-visible .y-axis {
                height: 50px !important;
                font-size: 7px !important;
            }
            .coverage-detail.print-visible .day-label {
                font-size: 10px !important;
                margin-bottom: 2px !important;
            }
            .coverage-detail.print-visible .time-labels {
                font-size: 7px !important;
                margin-top: 2px !important;
            }
            .coverage-detail.print-visible .summary {
                font-size: 8px !important;
                margin-top: 2px !important;
            }
            .coverage-detail.print-visible .graph-legend {
                font-size: 8px !important;
                margin-bottom: 3px !important;
                gap: 8px !important;
            }
            .coverage-detail.print-visible #coverageGraph > div {
                padding: 4px !important;
                min-width: 70px !important;
            }
            .rota-container {
                box-shadow: none;
                overflow: visible;
                margin-bottom: 5px;
            }
            table {
                min-width: auto;
                width: 100%;
            }
            .header-bar {
                display: none !important;
            }
            .print-title {
                display: block !important;
                font-size: 16px;
                margin-bottom: 5px;
            }
            .print-week {
                display: block !important;
            }
            .print-footer {
                display: flex !important;
                justify-content: space-between;
                margin-top: 10px;
                font-size: 10px;
                color: #666;
            }
            .print-notes {
                display: block !important;
                margin-top: 10px;
            }
            .staff-name-input {
                border: none;
                background: transparent;
                font-weight: bold;
                font-size: 10px;
            }
            td.shift-cell {
                height: auto;
                padding: 4px 3px;
            }
            th, td {
                padding: 4px 3px;
                font-size: 10px;
            }
            td.shift-cell small {
                font-size: 8px;
            }
            td.shift-cell.early { background: #d4edda !important; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
            td.shift-cell.late { background: #cce5ff !important; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
            td.shift-cell.mid { background: #fff3cd !important; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
            td.shift-cell.long { background: #f8d7da !important; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
            td.shift-cell.split { background: #e2d5f1 !important; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
            td.shift-cell.off { background: #f5f5f5 !important; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
            th { background: #34495e !important; color: #fff !important; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
            th.weekend { background: #8e44ad !important; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
        }
        
        .rota-container {
            background: var(--card-bg);
            border-radius: 8px;
            overflow-x: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 800px;
        }
        th, td {
            border: 1px solid var(--border-color);
            padding: 10px;
            text-align: center;
        }
        th {
            background: var(--header-bg);
            color: #fff;
            font-weight: 500;
        }
        th.weekend {
            background: var(--weekend-bg);
        }
        .staff-name {
            background: var(--staff-row-bg);
            font-weight: 500;
            text-align: left;
            min-width: 120px;
        }
        .staff-hours {
            background: var(--staff-row-bg);
            font-size: 12px;
            min-width: 80px;
        }
        .staff-hours.over { color: #e74c3c; font-weight: bold; }
        .staff-hours.under { color: #e67e22; }
        .staff-hours.exact { color: #27ae60; font-weight: bold; }
        
        td.shift-cell {
            cursor: pointer;
            transition: all 0.2s;
            min-width: 100px;
            height: 60px;
            vertical-align: middle;
            background: var(--card-bg);
        }
        td.shift-cell:hover {
            background: var(--staff-row-bg);
            opacity: 0.9;
        }
        td.shift-cell.has-shift {
            font-size: 13px;
        }
        td.shift-cell.early {
            background: var(--early-bg);
            color: var(--early-text);
        }
        td.shift-cell.late {
            background: var(--late-bg);
            color: var(--late-text);
        }
        td.shift-cell.mid {
            background: var(--mid-bg);
            color: var(--mid-text);
        }
        td.shift-cell.long {
            background: var(--long-bg);
            color: var(--long-text);
        }
        td.shift-cell.split {
            background: var(--split-bg);
            color: var(--split-text);
        }
        td.shift-cell.off {
            background: var(--off-bg);
            color: var(--off-text);
        }
        
        .coverage-row td {
            background: var(--mid-bg);
            color: var(--mid-text);
            font-weight: 500;
            font-size: 12px;
        }
        .coverage-row td.good { background: var(--early-bg); color: var(--early-text); }
        .coverage-row td.warning { background: var(--mid-bg); color: var(--mid-text); }
        .coverage-row td.bad { background: var(--long-bg); color: var(--long-text); }
        
        .staff-name-input {
            width: 100%;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            font-size: 14px;
            background: var(--input-bg);
            color: var(--text-color);
        }
        
        .legend {
            margin-top: 20px;
            padding: 15px;
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .legend h4 {
            margin-top: 0;
        }
        .legend-items {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }
        .legend-color.early-legend { background: var(--early-bg); }
        .legend-color.late-legend { background: var(--late-bg); }
        .legend-color.mid-legend { background: var(--mid-bg); }
        .legend-color.long-legend { background: var(--long-bg); }
        .legend-color.split-legend { background: var(--split-bg); }
        .legend-color.off-legend { background: var(--off-bg); border: 1px solid var(--border-color); }
        
        .coverage-detail {
            margin-top: 20px;
            padding: 15px;
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .coverage-detail h4 {
            margin-top: 0;
        }
        .time-grid {
            display: grid;
            grid-template-columns: 80px repeat(7, 1fr);
            gap: 2px;
            font-size: 11px;
        }
        .time-grid .header {
            background: var(--header-bg);
            color: #fff;
            padding: 5px;
            text-align: center;
            font-weight: bold;
        }
        .time-grid .weekend-header {
            background: var(--weekend-bg);
        }
        .time-grid .time-label {
            background: var(--staff-row-bg);
            padding: 3px 5px;
            text-align: right;
            color: var(--text-color);
        }
        .time-grid .time-slot {
            padding: 3px;
            text-align: center;
        }
        .time-slot.gap { background: #f8d7da; color: #721c24; font-weight: bold; }
        .time-slot.early-cover { background: #d4edda; }
        .time-slot.late-cover { background: #cce5ff; }
        .time-slot.mid-cover { background: #fff3cd; }
        .time-slot.long-cover { background: #f8d7da; }
        .time-slot.split-cover { background: #e2d5f1; }
        .time-slot.mixed-cover { background: linear-gradient(135deg, #d4edda 50%, #cce5ff 50%); }
        
        /* Generation result messages */
        .generation-result {
            margin-top: 10px;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 13px;
            line-height: 1.5;
        }
        .generation-success {
            background: var(--early-bg);
            color: var(--early-text);
            border: 1px solid currentColor;
        }
        .generation-warning {
            background: var(--mid-bg);
            color: var(--mid-text);
            border: 1px solid currentColor;
        }
        .generation-error {
            background: var(--long-bg);
            color: var(--long-text);
            border: 1px solid currentColor;
        }
    </style>
</head>
<body>
    <div class="header-bar" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <div></div>
        <h1 style="margin: 0;">Xrota</h1>
        <button id="darkModeToggle" onclick="toggleDarkMode()" style="padding: 8px 12px; border: none; border-radius: 5px; cursor: pointer; background: var(--header-bg); color: #fff;">
            Dark Mode
        </button>
    </div>
    <h1 class="print-title" style="display: none; text-align: center; margin: 0 0 5px;">Xrota</h1>
    <p class="print-week" id="printWeek" style="display: none; text-align: center; margin: 0 0 10px; font-size: 14px; font-weight: bold;"></p>
    
    <div class="week-selector" style="background: var(--card-bg); padding: 15px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center;">
        <label style="font-weight: 500; margin-right: 10px; color: var(--text-muted);">Week starting:</label>
        <button onclick="changeWeek(-1)" style="padding: 5px 10px; cursor: pointer; background: var(--header-bg); color: #fff; border: none; border-radius: 4px;">&lt; Prev</button>
        <span id="weekDisplay" style="font-size: 18px; font-weight: bold; margin: 0 15px; color: var(--text-color);"></span>
        <button onclick="changeWeek(1)" style="padding: 5px 10px; cursor: pointer; background: var(--header-bg); color: #fff; border: none; border-radius: 4px;">Next &gt;</button>
    </div>
    
    <div class="info-bar">
        <div class="info-item">
            <label>Operating Hours</label>
            <span>08:00 - 20:30</span>
        </div>
        <div class="info-item">
            <label>Coverage Required</label>
            <span>1-2 (3 changeover)</span>
        </div>
        <div class="info-item">
            <label>Target Hours/Staff</label>
            <span>37.5 hrs</span>
        </div>
        <div class="info-item">
            <label>Total Staff Hours</label>
            <span id="totalHours">0</span>
        </div>
        <div class="info-item">
            <label>Coverage Status</label>
            <span id="coverageStatus">-</span>
        </div>
    </div>
    
    <div class="controls">
        <div class="action-btns" style="margin-bottom: 15px;">
            <button class="action-btn primary" onclick="generateBestFitRota()">Generate This Week</button>
            <button class="action-btn secondary" onclick="generate10Weeks()" style="background: #8e44ad;">Generate 10 Weeks</button>
            <button class="action-btn danger" onclick="clearAll()">Clear All</button>
            <button class="action-btn print" onclick="printRota()">Print Weekly Schedule</button>
        </div>
        <div id="generationResult" class="generation-result" style="display: none;"></div>
        <p style="margin: 10px 0; color: var(--text-muted); font-size: 13px;">Auto-generation uses Early, Mid, and Late shifts. Coverage: 1-2 staff (max 3 during 12:00-16:30 changeover). Each person works exactly 37.5 hours.</p>
        <h3>Shift Templates (click to select, then click cells)</h3>
        <div class="shift-templates">
            <button class="shift-btn" data-shift="early">Early (08:00-16:30)</button>
            <button class="shift-btn" data-shift="mid">Mid (10:00-18:30)</button>
            <button class="shift-btn" data-shift="late">Late (12:00-20:30)</button>
            <button class="shift-btn" data-shift="long">Long (08:00-20:30)</button>
            <button class="shift-btn" data-shift="split">Split (08:00-13:00 & 16:00-20:30)</button>
            <button class="shift-btn off" data-shift="off">Day Off</button>
        </div>
        <p style="margin: 10px 0 0; color: var(--text-muted); font-size: 13px;">All shifts include 1 hour lunch break. Times shown are working hours.</p>
    </div>
    
    <div class="rota-container">
        <table id="rotaTable">
            <thead>
                <tr>
                    <th>Staff</th>
                    <th>Mon</th>
                    <th>Tue</th>
                    <th>Wed</th>
                    <th>Thu</th>
                    <th>Fri</th>
                    <th class="weekend">Sat</th>
                    <th class="weekend">Sun</th>
                    <th>Weekly Hours</th>
                </tr>
            </thead>
            <tbody id="rotaBody">
            </tbody>
        </table>
    </div>
    
    <div class="coverage-detail">
        <h4>Hourly Coverage Graph</h4>
        <div class="graph-legend" style="display: flex; gap: 15px; margin-bottom: 15px; font-size: 12px; flex-wrap: wrap;">
            <span><span style="display: inline-block; width: 12px; height: 12px; background: #27ae60; border-radius: 2px; margin-right: 5px;"></span>1-2 staff</span>
            <span><span style="display: inline-block; width: 12px; height: 12px; background: #3498db; border-radius: 2px; margin-right: 5px;"></span>3 staff (changeover 12:00-16:30)</span>
            <span><span style="display: inline-block; width: 12px; height: 12px; background: #e74c3c; border-radius: 2px; margin-right: 5px;"></span>No coverage</span>
            <span><span style="display: inline-block; width: 12px; height: 12px; background: #e67e22; border-radius: 2px; margin-right: 5px;"></span>4+ staff (over)</span>
        </div>
        <div id="coverageGraph" style="display: flex; gap: 10px; flex-wrap: nowrap;">
        </div>
    </div>
    
    <div class="weekend-stats" style="margin-top: 20px; padding: 15px; background: var(--card-bg); border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
        <h4 style="margin-top: 0;">Weekend Balance (Rolling 10 Weeks)</h4>
        <div id="weekendStatsContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
        </div>
    </div>
    
    <div class="print-notes" style="display: none;">
        <h4 style="margin: 0 0 5px; font-size: 11px;">Notes:</h4>
        <div style="border: 1px solid #ccc; min-height: 60px; border-radius: 4px;"></div>
    </div>
    
    <footer style="margin-top: 30px; padding: 20px; text-align: center; color: var(--text-muted); font-size: 14px;">
        Copyright 2026 <a href="https://videowalrus.com" target="_blank" style="color: #3498db; text-decoration: none;">Video Walrus Ltd</a>
    </footer>
    
    <div class="print-footer" style="display: none; justify-content: space-between;">
        <span id="printDate"></span>
        <span>Copyright 2026 Video Walrus Ltd - videowalrus.com</span>
    </div>

    <script>
        const DAYS = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
        const DAY_NAMES = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
        const TARGET_HOURS = 37.5;
        
        // Operating hours: 8:00 (8) to 20:30 (20.5)
        const OPEN_TIME = 8;
        const CLOSE_TIME = 20.5;
        
        // Shifts with start/end times (includes 1hr lunch break in duration calc)
        const SHIFTS = {
            early: { 
                name: 'Early', 
                time: '08:00-16:30', 
                hours: 7.5,  // 8.5 hrs minus 1hr lunch
                start: 8, 
                end: 16.5,
                coverage: [[8, 16.5]]  // continuous coverage
            },
            late: { 
                name: 'Late', 
                time: '12:00-20:30', 
                hours: 7.5,
                start: 12, 
                end: 20.5,
                coverage: [[12, 20.5]]
            },
            mid: { 
                name: 'Mid', 
                time: '10:00-18:30', 
                hours: 7.5,
                start: 10, 
                end: 18.5,
                coverage: [[10, 18.5]]
            },
            long: { 
                name: 'Long', 
                time: '08:00-20:30', 
                hours: 11.5,  // 12.5 hrs minus 1hr lunch
                start: 8, 
                end: 20.5,
                coverage: [[8, 20.5]]
            },
            split: { 
                name: 'Split', 
                time: '08:00-13:00 & 16:00-20:30', 
                hours: 9.5,  // 5 + 4.5
                start: 8, 
                end: 20.5,
                coverage: [[8, 13], [16, 20.5]]  // gap 13:00-16:00
            },
            off: { 
                name: 'OFF', 
                time: '', 
                hours: 0,
                coverage: []
            }
        };
        
        let staff = [
            { id: 1, name: 'Staff 1' },
            { id: 2, name: 'Staff 2' },
            { id: 3, name: 'Staff 3' },
            { id: 4, name: 'Staff 4' },
            { id: 5, name: 'Staff 5' }
        ];
        
        let rota = {};
        let selectedShift = null;
        let currentWeekStart = getNextMonday();
        let dayOffPatterns = {}; // Persistent day off patterns: { staffId: ['mon', 'tue', ...] }
        
        // 10-week weekend tracking
        function getWeekendStatsForPeriod(weeksBack = 10) {
            // Get weekend shift counts for each staff over rolling 10-week window
            const stats = {};
            staff.forEach(s => {
                stats[s.id] = { sat: 0, sun: 0, total: 0, daysOff: 0, weeks: [] };
            });
            
            // Go back 'weeksBack' weeks from current week
            for (let w = 0; w < weeksBack; w++) {
                const weekDate = new Date(currentWeekStart);
                weekDate.setDate(weekDate.getDate() - (w * 7));
                const weekKey = getWeekKey(weekDate);
                const saved = localStorage.getItem('staffRota_' + weekKey);
                
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        staff.forEach(s => {
                            const staffRota = data.rota[s.id];
                            if (staffRota) {
                                if (staffRota.sat && staffRota.sat !== 'off') {
                                    stats[s.id].sat++;
                                    stats[s.id].total++;
                                }
                                if (staffRota.sun && staffRota.sun !== 'off') {
                                    stats[s.id].sun++;
                                    stats[s.id].total++;
                                }
                                // Count total days off
                                DAYS.forEach(day => {
                                    if (staffRota[day] === 'off') {
                                        stats[s.id].daysOff++;
                                    }
                                });
                                stats[s.id].weeks.push(weekKey);
                            }
                        });
                    } catch (e) {}
                }
            }
            
            return stats;
        }
        
        function getAverageWeekendShifts10Week() {
            const stats = getWeekendStatsForPeriod(10);
            let total = 0;
            let count = 0;
            staff.forEach(s => {
                total += stats[s.id].total;
                count++;
            });
            return count > 0 ? total / count : 0;
        }
        
        function renderWeekendStats() {
            const container = document.getElementById('weekendStatsContainer');
            container.innerHTML = '';
            
            const stats = getWeekendStatsForPeriod(10);
            const avgTotal = getAverageWeekendShifts10Week();
            
            // Include current week's planned shifts and days off
            staff.forEach(s => {
                if (rota[s.id]) {
                    if (rota[s.id].sat && rota[s.id].sat !== 'off') {
                        stats[s.id].sat++;
                        stats[s.id].total++;
                    }
                    if (rota[s.id].sun && rota[s.id].sun !== 'off') {
                        stats[s.id].sun++;
                        stats[s.id].total++;
                    }
                    // Count days off for current week
                    DAYS.forEach(day => {
                        if (rota[s.id][day] === 'off') {
                            stats[s.id].daysOff++;
                        }
                    });
                }
            });
            
            // Calculate average days off
            let totalDaysOff = 0;
            staff.forEach(s => {
                totalDaysOff += stats[s.id].daysOff;
            });
            const avgDaysOff = staff.length > 0 ? totalDaysOff / staff.length : 0;
            
            staff.forEach(s => {
                const stat = stats[s.id];
                const div = document.createElement('div');
                div.style.cssText = 'background: var(--staff-row-bg); padding: 10px; border-radius: 5px; text-align: center;';
                
                let statusColor = '#27ae60'; // good
                if (stat.total > avgTotal + 2) {
                    statusColor = '#e74c3c'; // too many
                } else if (stat.total < avgTotal - 2) {
                    statusColor = '#3498db'; // too few, prioritise
                }
                
                div.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 5px;">${s.name}</div>
                    <div style="font-size: 24px; color: ${statusColor}; font-weight: bold;">${stat.total}</div>
                    <div style="font-size: 11px; color: var(--text-muted);">Sat: ${stat.sat} | Sun: ${stat.sun}</div>
                    <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">Days off: ${stat.daysOff}</div>
                `;
                container.appendChild(div);
            });
            
            // Add average indicator
            const avgDiv = document.createElement('div');
            avgDiv.style.cssText = 'background: var(--header-bg); color: #fff; padding: 10px; border-radius: 5px; text-align: center;';
            avgDiv.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 5px;">Average</div>
                <div style="font-size: 24px; font-weight: bold;">${avgTotal.toFixed(1)}</div>
                <div style="font-size: 11px; opacity: 0.8;">weekend shifts</div>
                <div style="font-size: 11px; opacity: 0.8; margin-top: 4px;">Days off: ${avgDaysOff.toFixed(1)}</div>
            `;
            container.appendChild(avgDiv);
        }
        
        function getNextMonday() {
            const today = new Date();
            const dayOfWeek = today.getDay();
            const daysUntilNextMonday = dayOfWeek === 0 ? 1 : 8 - dayOfWeek;
            const nextMonday = new Date(today);
            nextMonday.setDate(today.getDate() + daysUntilNextMonday);
            nextMonday.setHours(0, 0, 0, 0);
            return nextMonday;
        }
        
        function getWeekKey(date) {
            return date.toISOString().split('T')[0];
        }
        
        function formatWeekDisplay(monday) {
            const sunday = new Date(monday);
            sunday.setDate(monday.getDate() + 6);
            const formatDate = (d) => d.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
            return `${formatDate(monday)} - ${formatDate(sunday)}`;
        }
        
        function updateWeekDisplay() {
            document.getElementById('weekDisplay').textContent = formatWeekDisplay(currentWeekStart);
        }
        
        function changeWeek(direction) {
            // Save current week before changing
            saveToLocalStorage();
            
            // Move week
            currentWeekStart.setDate(currentWeekStart.getDate() + (direction * 7));
            
            // Load new week's data
            loadWeekData();
            updateWeekDisplay();
            renderTable();
        }
        
        function loadWeekData() {
            const weekKey = getWeekKey(currentWeekStart);
            const saved = localStorage.getItem('staffRota_' + weekKey);
            
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    staff = data.staff;
                    rota = data.rota;
                    return;
                } catch (e) {}
            }
            
            // Load staff names from any existing week, but clear rota
            const staffData = localStorage.getItem('staffRota_staff');
            if (staffData) {
                try {
                    staff = JSON.parse(staffData);
                } catch (e) {}
            }
            
            // Initialize empty rota for this week
            rota = {};
            staff.forEach(s => {
                rota[s.id] = {};
                DAYS.forEach(day => {
                    rota[s.id][day] = null;
                });
            });
            
            // Apply persistent day off patterns to new week
            applyDayOffPatterns();
        }
        
        function init() {
            // Load staff names
            const staffData = localStorage.getItem('staffRota_staff');
            if (staffData) {
                try {
                    staff = JSON.parse(staffData);
                } catch (e) {}
            }
            
            // Load persistent day off patterns
            loadDayOffPatterns();
            
            // Load current week's data
            loadWeekData();
            
            updateWeekDisplay();
            renderTable();
            renderTimeGrid();
            setupShiftButtons();
        }
        
        function saveToLocalStorage() {
            const weekKey = getWeekKey(currentWeekStart);
            const data = {
                staff: staff,
                rota: rota
            };
            localStorage.setItem('staffRota_' + weekKey, JSON.stringify(data));
            // Also save staff names separately for use across weeks
            localStorage.setItem('staffRota_staff', JSON.stringify(staff));
        }
        
        // Day Off persistence functions
        function loadDayOffPatterns() {
            const saved = localStorage.getItem('staffRota_dayOffPatterns');
            if (saved) {
                try {
                    dayOffPatterns = JSON.parse(saved);
                } catch (e) {
                    dayOffPatterns = {};
                }
            }
        }
        
        function saveDayOffPatterns() {
            localStorage.setItem('staffRota_dayOffPatterns', JSON.stringify(dayOffPatterns));
        }
        
        function applyDayOffPatterns() {
            // Apply persistent day off patterns to current week's rota
            Object.keys(dayOffPatterns).forEach(staffId => {
                const id = parseInt(staffId);
                if (rota[id]) {
                    dayOffPatterns[staffId].forEach(day => {
                        if (rota[id][day] === null) {
                            rota[id][day] = 'off';
                        }
                    });
                }
            });
        }
        
        // Best-fit algorithm helper functions
        function getConsecutiveWorkDays(staffId, fromDay, direction) {
            // Count consecutive working days before (direction=-1) or after (direction=1) fromDay
            const dayIndex = DAYS.indexOf(fromDay);
            let count = 0;
            let i = dayIndex + direction;
            
            while (i >= 0 && i < DAYS.length) {
                const shift = rota[staffId][DAYS[i]];
                if (shift && shift !== 'off') {
                    count++;
                    i += direction;
                } else {
                    break;
                }
            }
            return count;
        }
        
        function getMaxConsecutiveWorkDays(staffId) {
            // Get the maximum number of consecutive working days for a staff member
            let maxConsecutive = 0;
            let current = 0;
            
            DAYS.forEach(day => {
                const shift = rota[staffId][day];
                if (shift && shift !== 'off') {
                    current++;
                    maxConsecutive = Math.max(maxConsecutive, current);
                } else {
                    current = 0;
                }
            });
            return maxConsecutive;
        }
        
        function getWeekendShiftCount(staffId) {
            // Count weekend shifts (Sat + Sun) for a staff member
            let count = 0;
            ['sat', 'sun'].forEach(day => {
                const shift = rota[staffId][day];
                if (shift && shift !== 'off') {
                    count++;
                }
            });
            return count;
        }
        
        function getAverageWeekendShifts(staffHours) {
            // Calculate average weekend shifts across all available staff
            let total = 0;
            let availableCount = 0;
            
            staff.forEach(s => {
                // Only count staff who aren't fully on day off for weekends
                const satOff = rota[s.id]['sat'] === 'off';
                const sunOff = rota[s.id]['sun'] === 'off';
                if (!satOff || !sunOff) {
                    total += getWeekendShiftCount(s.id);
                    availableCount++;
                }
            });
            
            return availableCount > 0 ? total / availableCount : 0;
        }
        
        function wouldCreateConsecutiveDaysOff(staffId, day) {
            // Check if NOT assigning a shift on this day would create consecutive days off
            const dayIndex = DAYS.indexOf(day);
            
            // Check day before
            if (dayIndex > 0) {
                const prevShift = rota[staffId][DAYS[dayIndex - 1]];
                if (!prevShift || prevShift === 'off') {
                    return true;
                }
            }
            
            // Check day after
            if (dayIndex < DAYS.length - 1) {
                const nextShift = rota[staffId][DAYS[dayIndex + 1]];
                if (!nextShift || nextShift === 'off') {
                    return true;
                }
            }
            
            return false;
        }
        
        function scoreStaffForShift(staffId, day, shiftType, staffHours, assignedToday, weekendStats10Week) {
            // Returns numeric score (higher = better fit)
            // Returns -Infinity if staff is blocked
            
            let score = 0;
            
            // BLOCKING CONDITIONS
            // Staff has Day Off on this day
            if (rota[staffId][day] === 'off') return -Infinity;
            
            // Staff already assigned a shift today
            if (assignedToday.includes(staffId)) return -Infinity;
            
            // Would exceed 37.5 hours
            if (staffHours[staffId] + SHIFTS[shiftType].hours > TARGET_HOURS) return -Infinity;
            
            // Would exceed 5 consecutive working days
            const consecutiveBefore = getConsecutiveWorkDays(staffId, day, -1);
            const consecutiveAfter = getConsecutiveWorkDays(staffId, day, 1);
            if (consecutiveBefore + 1 + consecutiveAfter > 5) return -Infinity;
            
            // SCORING FACTORS
            // Hours remaining (more remaining = higher score)
            const hoursRemaining = TARGET_HOURS - staffHours[staffId];
            score += hoursRemaining * 2;
            
            // Weekend balance using 10-week rolling window
            if (day === 'sat' || day === 'sun') {
                const avg10Week = getAverageWeekendShifts10Week();
                const staffWeekendTotal = weekendStats10Week[staffId] ? weekendStats10Week[staffId].total : 0;
                
                // Strong preference for staff with fewer weekend shifts over 10 weeks
                if (staffWeekendTotal < avg10Week - 1) {
                    score += 15; // Big bonus for under-worked weekenders
                } else if (staffWeekendTotal < avg10Week) {
                    score += 8;
                } else if (staffWeekendTotal > avg10Week + 1) {
                    score -= 10; // Penalty for over-worked weekenders
                } else if (staffWeekendTotal > avg10Week) {
                    score -= 5;
                }
            }
            
            // CONSECUTIVE DAYS OFF - Strong preference
            // Penalise assigning shift if it would break up potential consecutive days off
            if (wouldBreakConsecutiveDaysOff(staffId, day)) {
                score -= 20; // Strong penalty for breaking consecutive days off
            }
            
            // Bonus if adjacent day already has a day off (encourages consecutive)
            if (hasAdjacentDayOff(staffId, day)) {
                score -= 10; // Penalty - prefer to keep this as day off too
            }
            
            // Random factor for variety (0-3)
            score += Math.random() * 3;
            
            return score;
        }
        
        function wouldBreakConsecutiveDaysOff(staffId, day) {
            // Check if assigning a shift here would break up two adjacent days off
            const dayIndex = DAYS.indexOf(day);
            
            // Check if both adjacent days are off (we'd be breaking a block)
            const prevDay = dayIndex > 0 ? rota[staffId][DAYS[dayIndex - 1]] : null;
            const nextDay = dayIndex < DAYS.length - 1 ? rota[staffId][DAYS[dayIndex + 1]] : null;
            
            // If both neighbours are day off or null (potential day off), don't assign here
            const prevIsOff = prevDay === 'off' || prevDay === null;
            const nextIsOff = nextDay === 'off' || nextDay === null;
            
            return prevIsOff && nextIsOff;
        }
        
        function hasAdjacentDayOff(staffId, day) {
            // Check if there's already a confirmed day off adjacent to this day
            const dayIndex = DAYS.indexOf(day);
            
            if (dayIndex > 0 && rota[staffId][DAYS[dayIndex - 1]] === 'off') {
                return true;
            }
            if (dayIndex < DAYS.length - 1 && rota[staffId][DAYS[dayIndex + 1]] === 'off') {
                return true;
            }
            return false;
        }
        
        function validateRota() {
            // Returns { valid: boolean, warnings: [], errors: [] }
            const result = { valid: true, warnings: [], errors: [] };
            
            // Changeover period where 3 staff is acceptable
            const CHANGEOVER_START = 12;
            const CHANGEOVER_END = 16.5;
            
            // Check each day has 1-2 staff coverage (1-3 during changeover)
            DAYS.forEach(day => {
                const dayName = day.charAt(0).toUpperCase() + day.slice(1);
                let hasGap = false;
                let hasOver = false;
                
                for (let t = OPEN_TIME; t < CLOSE_TIME; t += 0.5) {
                    const count = getStaffCountAtTime(day, t);
                    const isChangeover = (t >= CHANGEOVER_START && t < CHANGEOVER_END);
                    const maxAllowed = isChangeover ? 3 : 2;
                    
                    if (count === 0) {
                        hasGap = true;
                    }
                    if (count > maxAllowed) {
                        hasOver = true;
                    }
                }
                
                if (hasGap) {
                    result.valid = false;
                    result.errors.push(`${dayName}: Coverage gap - no staff at some times`);
                }
                if (hasOver) {
                    result.warnings.push(`${dayName}: Too many staff at some times`);
                }
            });
            
            // Check staff hours
            staff.forEach(s => {
                const hours = calculateStaffHours(s.id);
                if (hours > TARGET_HOURS) {
                    result.warnings.push(`${s.name}: ${hours}hrs exceeds target ${TARGET_HOURS}hrs`);
                } else if (hours < TARGET_HOURS - 0.1) {
                    result.warnings.push(`${s.name}: Only ${hours}hrs assigned (target: ${TARGET_HOURS}hrs)`);
                }
            });
            
            // Check consecutive working days
            staff.forEach(s => {
                const maxConsecutive = getMaxConsecutiveWorkDays(s.id);
                if (maxConsecutive > 5) {
                    result.warnings.push(`${s.name}: Working ${maxConsecutive} consecutive days (max: 5)`);
                }
            });
            
            // Check for consecutive days off
            staff.forEach(s => {
                if (!hasConsecutiveDaysOff(s.id)) {
                    result.warnings.push(`${s.name}: Days off are not consecutive`);
                }
            });
            
            return result;
        }
        
        function hasConsecutiveDaysOff(staffId) {
            // Check if this staff member has at least 2 consecutive days off
            for (let i = 0; i < DAYS.length - 1; i++) {
                const today = rota[staffId][DAYS[i]];
                const tomorrow = rota[staffId][DAYS[i + 1]];
                if (today === 'off' && tomorrow === 'off') {
                    return true;
                }
            }
            // Also check Sun-Mon wrap (if they have Sun off and Mon off next week concept)
            // For now, just check within the week
            return false;
        }
        
        function showGenerationResult(result) {
            const el = document.getElementById('generationResult');
            el.style.display = 'block';
            
            if (result.errors.length > 0) {
                el.className = 'generation-result generation-error';
                el.innerHTML = '<strong>Generation completed with issues:</strong><br>' + 
                    result.errors.concat(result.warnings).map(m => '• ' + m).join('<br>');
            } else if (result.warnings.length > 0) {
                el.className = 'generation-result generation-warning';
                el.innerHTML = '<strong>Rota generated with warnings:</strong><br>' + 
                    result.warnings.map(m => '• ' + m).join('<br>');
            } else {
                el.className = 'generation-result generation-success';
                el.innerHTML = '<strong>Rota generated successfully!</strong><br>' +
                    '• Full coverage: 1-2 staff (max 3 during 12:00-16:30 changeover)<br>' +
                    '• All staff at target hours (37.5hrs)<br>' +
                    '• All staff have 2 consecutive days off<br>' +
                    '• Weekend shifts balanced (10-week rolling)';
            }
        }
        
        function generateBestFitRota() {
            // Available shifts: Early, Mid, Late (all 7.5 hours)
            const availableShifts = ['early', 'mid', 'late'];
            
            // STEP 1: Clear existing shifts (EXCEPT Day Off from patterns)
            staff.forEach(s => {
                DAYS.forEach(day => {
                    const hasPatternDayOff = dayOffPatterns[s.id] && dayOffPatterns[s.id].includes(day);
                    if (hasPatternDayOff) {
                        rota[s.id][day] = 'off';
                    } else {
                        rota[s.id][day] = null;
                    }
                });
            });
            
            // STEP 2: Initialize tracking
            let staffHours = {};
            staff.forEach(s => staffHours[s.id] = 0);
            
            // Get 10-week weekend stats for balancing
            const weekendStats10Week = getWeekendStatsForPeriod(10);
            
            // STEP 3: Pre-plan consecutive days off for each staff member
            planConsecutiveDaysOff(weekendStats10Week);
            
            // STEP 4: Assign shifts day by day, ensuring 1-2 coverage constraint
            DAYS.forEach(day => {
                let assignedToday = [];
                
                // Must have at least 1 Early (for 08:00-10:00 coverage)
                let earlyScores = staff.map(s => ({
                    id: s.id,
                    score: scoreStaffForShift(s.id, day, 'early', staffHours, assignedToday, weekendStats10Week)
                })).filter(s => s.score > -Infinity);
                earlyScores.sort((a, b) => b.score - a.score);
                
                if (earlyScores.length > 0) {
                    rota[earlyScores[0].id][day] = 'early';
                    staffHours[earlyScores[0].id] += SHIFTS.early.hours;
                    assignedToday.push(earlyScores[0].id);
                }
                
                // Must have at least 1 Late (for 18:30-20:30 coverage)
                let lateScores = staff.map(s => ({
                    id: s.id,
                    score: scoreStaffForShift(s.id, day, 'late', staffHours, assignedToday, weekendStats10Week)
                })).filter(s => s.score > -Infinity);
                lateScores.sort((a, b) => b.score - a.score);
                
                if (lateScores.length > 0) {
                    rota[lateScores[0].id][day] = 'late';
                    staffHours[lateScores[0].id] += SHIFTS.late.hours;
                    assignedToday.push(lateScores[0].id);
                }
            });
            
            // STEP 5: Fill remaining hours - each staff needs exactly 5 shifts (37.5 hours)
            let iterations = 0;
            const maxIterations = 100;
            
            while (iterations < maxIterations) {
                iterations++;
                
                // Find staff who still need shifts (under 37.5 hours)
                const staffNeedingHours = staff
                    .filter(s => staffHours[s.id] < TARGET_HOURS)
                    .sort((a, b) => staffHours[a.id] - staffHours[b.id]);
                
                if (staffNeedingHours.length === 0) break;
                
                let assigned = false;
                
                for (const s of staffNeedingHours) {
                    // Shuffle days for variety
                    const shuffledDays = [...DAYS].sort(() => Math.random() - 0.5);
                    
                    for (const day of shuffledDays) {
                        if (rota[s.id][day]) continue; // Already has shift or day off
                        
                        // Try each shift type, check if it would exceed 2 staff at any time
                        const shuffledShifts = [...availableShifts].sort(() => Math.random() - 0.5);
                        
                        for (const shiftType of shuffledShifts) {
                            // Check if adding this shift would cause >2 staff at any point
                            const wouldExceedMax = wouldExceedMaxCoverage(day, shiftType, 2);
                            
                            if (!wouldExceedMax) {
                                const score = scoreStaffForShift(s.id, day, shiftType, staffHours, [], weekendStats10Week);
                                if (score > -Infinity) {
                                    rota[s.id][day] = shiftType;
                                    staffHours[s.id] += SHIFTS[shiftType].hours;
                                    assigned = true;
                                    break;
                                }
                            }
                        }
                        if (assigned) break;
                    }
                    if (assigned) break;
                }
                
                if (!assigned) break; // No more valid assignments possible
            }
            
            // STEP 6: Mark remaining empty slots as Day Off
            staff.forEach(s => {
                DAYS.forEach(day => {
                    if (!rota[s.id][day]) {
                        rota[s.id][day] = 'off';
                    }
                });
            });
            
            // STEP 7: Validate and show results
            const result = validateRota();
            showGenerationResult(result);
            
            // STEP 8: Save and render
            saveToLocalStorage();
            renderTable();
            renderWeekendStats();
        }
        
        function generate10Weeks() {
            if (!confirm('This will generate rotas for 10 weeks starting from the current week. Any existing rotas for these weeks will be overwritten. Continue?')) {
                return;
            }
            
            const startWeek = new Date(currentWeekStart);
            const results = [];
            
            // Generate each week
            for (let w = 0; w < 10; w++) {
                // Set current week
                currentWeekStart = new Date(startWeek);
                currentWeekStart.setDate(startWeek.getDate() + (w * 7));
                
                // Initialize empty rota for this week
                rota = {};
                staff.forEach(s => {
                    rota[s.id] = {};
                    DAYS.forEach(day => {
                        const hasPatternDayOff = dayOffPatterns[s.id] && dayOffPatterns[s.id].includes(day);
                        rota[s.id][day] = hasPatternDayOff ? 'off' : null;
                    });
                });
                
                // Generate rota for this week (silent mode - no UI updates)
                generateWeekSilent();
                
                // Save this week
                saveToLocalStorage();
                
                // Validate and collect results
                const validation = validateRota();
                results.push({
                    week: w + 1,
                    date: formatWeekDisplay(currentWeekStart),
                    errors: validation.errors.length,
                    warnings: validation.warnings.length
                });
            }
            
            // Return to first week of the generated period
            currentWeekStart = new Date(startWeek);
            loadWeekData();
            updateWeekDisplay();
            renderTable();
            
            // Show summary
            const totalErrors = results.reduce((sum, r) => sum + r.errors, 0);
            const totalWarnings = results.reduce((sum, r) => sum + r.warnings, 0);
            
            const el = document.getElementById('generationResult');
            el.style.display = 'block';
            
            if (totalErrors > 0) {
                el.className = 'generation-result generation-error';
                el.innerHTML = `<strong>10 weeks generated with issues:</strong><br>` +
                    `• ${totalErrors} errors, ${totalWarnings} warnings across all weeks<br>` +
                    `• Use Prev/Next to review each week`;
            } else if (totalWarnings > 0) {
                el.className = 'generation-result generation-warning';
                el.innerHTML = `<strong>10 weeks generated with warnings:</strong><br>` +
                    `• ${totalWarnings} warnings across all weeks<br>` +
                    `• Weekend shifts balanced over the period`;
            } else {
                el.className = 'generation-result generation-success';
                el.innerHTML = `<strong>10 weeks generated successfully!</strong><br>` +
                    `• Full 1-2 staff coverage on all days (3 during changeover)<br>` +
                    `• All staff at 37.5hrs each week<br>` +
                    `• 2 consecutive days off per person per week<br>` +
                    `• Weekend shifts balanced across 10 weeks`;
            }
        }
        
        function generateWeekSilent() {
            // Same as generateBestFitRota but without UI updates
            const availableShifts = ['early', 'mid', 'late'];
            
            let staffHours = {};
            staff.forEach(s => staffHours[s.id] = 0);
            
            const weekendStats10Week = getWeekendStatsForPeriod(10);
            
            // STEP 1: Pre-plan consecutive days off for each staff member
            // Each staff works 5 shifts (37.5hrs), so 2 days off per week
            // Try to make these consecutive
            planConsecutiveDaysOff(weekendStats10Week);
            
            // STEP 2: Assign minimum coverage: 1 Early + 1 Late per day
            DAYS.forEach(day => {
                let assignedToday = [];
                
                let earlyScores = staff.map(s => ({
                    id: s.id,
                    score: scoreStaffForShift(s.id, day, 'early', staffHours, assignedToday, weekendStats10Week)
                })).filter(s => s.score > -Infinity);
                earlyScores.sort((a, b) => b.score - a.score);
                
                if (earlyScores.length > 0) {
                    rota[earlyScores[0].id][day] = 'early';
                    staffHours[earlyScores[0].id] += SHIFTS.early.hours;
                    assignedToday.push(earlyScores[0].id);
                }
                
                let lateScores = staff.map(s => ({
                    id: s.id,
                    score: scoreStaffForShift(s.id, day, 'late', staffHours, assignedToday, weekendStats10Week)
                })).filter(s => s.score > -Infinity);
                lateScores.sort((a, b) => b.score - a.score);
                
                if (lateScores.length > 0) {
                    rota[lateScores[0].id][day] = 'late';
                    staffHours[lateScores[0].id] += SHIFTS.late.hours;
                    assignedToday.push(lateScores[0].id);
                }
            });
            
            // STEP 3: Fill remaining hours
            let iterations = 0;
            const maxIterations = 100;
            
            while (iterations < maxIterations) {
                iterations++;
                
                const staffNeedingHours = staff
                    .filter(s => staffHours[s.id] < TARGET_HOURS)
                    .sort((a, b) => staffHours[a.id] - staffHours[b.id]);
                
                if (staffNeedingHours.length === 0) break;
                
                let assigned = false;
                
                for (const s of staffNeedingHours) {
                    const shuffledDays = [...DAYS].sort(() => Math.random() - 0.5);
                    
                    for (const day of shuffledDays) {
                        if (rota[s.id][day]) continue;
                        
                        const shuffledShifts = [...availableShifts].sort(() => Math.random() - 0.5);
                        
                        for (const shiftType of shuffledShifts) {
                            const wouldExceedMax = wouldExceedMaxCoverage(day, shiftType, 2);
                            
                            if (!wouldExceedMax) {
                                const score = scoreStaffForShift(s.id, day, shiftType, staffHours, [], weekendStats10Week);
                                if (score > -Infinity) {
                                    rota[s.id][day] = shiftType;
                                    staffHours[s.id] += SHIFTS[shiftType].hours;
                                    assigned = true;
                                    break;
                                }
                            }
                        }
                        if (assigned) break;
                    }
                    if (assigned) break;
                }
                
                if (!assigned) break;
            }
            
            // Mark remaining as Day Off
            staff.forEach(s => {
                DAYS.forEach(day => {
                    if (!rota[s.id][day]) {
                        rota[s.id][day] = 'off';
                    }
                });
            });
        }
        
        function planConsecutiveDaysOff(weekendStats10Week) {
            // Pre-assign consecutive days off for each staff member
            // Each person needs 2 days off (works 5 x 7.5hr shifts = 37.5hrs)
            
            // Possible consecutive pairs (prefer mid-week to spread coverage)
            const consecutivePairs = [
                ['tue', 'wed'],
                ['wed', 'thu'],
                ['mon', 'tue'],
                ['thu', 'fri'],
                ['sat', 'sun'],  // Weekend pair - use for balancing
                ['fri', 'sat'],
                ['sun', 'mon']   // Wraps around - treat sun+mon as consecutive
            ];
            
            // Track how many staff are off each day
            const daysOffCount = {};
            DAYS.forEach(d => daysOffCount[d] = 0);
            
            // Count existing pattern day offs
            staff.forEach(s => {
                if (dayOffPatterns[s.id]) {
                    dayOffPatterns[s.id].forEach(day => {
                        if (rota[s.id][day] === 'off') {
                            daysOffCount[day]++;
                        }
                    });
                }
            });
            
            // Assign consecutive days off to each staff member
            // Shuffle staff order for fairness
            const shuffledStaff = [...staff].sort(() => Math.random() - 0.5);
            
            for (const s of shuffledStaff) {
                // Count existing days off from patterns
                let existingDaysOff = DAYS.filter(d => rota[s.id][d] === 'off');
                
                if (existingDaysOff.length >= 2) continue; // Already has enough days off
                
                // Score each consecutive pair
                const pairScores = consecutivePairs.map(pair => {
                    const [day1, day2] = pair;
                    let score = 0;
                    
                    // Can't use if already has shift or day off pattern conflict
                    if (rota[s.id][day1] && rota[s.id][day1] !== 'off') return { pair, score: -Infinity };
                    if (rota[s.id][day2] && rota[s.id][day2] !== 'off') return { pair, score: -Infinity };
                    
                    // Avoid days where too many are already off (need coverage)
                    // Max 2 staff off per day to ensure minimum coverage
                    if (daysOffCount[day1] >= 2) return { pair, score: -Infinity };
                    if (daysOffCount[day2] >= 2) return { pair, score: -Infinity };
                    
                    // Prefer days with fewer staff already off
                    score -= daysOffCount[day1] * 5;
                    score -= daysOffCount[day2] * 5;
                    
                    // Weekend balancing - prefer weekend off for those with fewer weekend shifts
                    const isWeekendPair = (day1 === 'sat' || day1 === 'sun' || day2 === 'sat' || day2 === 'sun');
                    if (isWeekendPair) {
                        const avg10Week = getAverageWeekendShifts10Week();
                        const staffWeekendTotal = weekendStats10Week[s.id] ? weekendStats10Week[s.id].total : 0;
                        
                        if (staffWeekendTotal > avg10Week + 1) {
                            score += 10; // Bonus for giving weekend off to overworked
                        } else if (staffWeekendTotal < avg10Week - 1) {
                            score -= 15; // Penalty - they need more weekend work
                        }
                    }
                    
                    // Random factor
                    score += Math.random() * 5;
                    
                    return { pair, score };
                });
                
                // Sort by score and pick best valid pair
                pairScores.sort((a, b) => b.score - a.score);
                
                const bestPair = pairScores.find(p => p.score > -Infinity);
                if (bestPair) {
                    const [day1, day2] = bestPair.pair;
                    rota[s.id][day1] = 'off';
                    rota[s.id][day2] = 'off';
                    daysOffCount[day1]++;
                    daysOffCount[day2]++;
                }
            }
        }
        
        function wouldExceedMaxCoverage(day, newShiftType, maxStaff) {
            // Check if adding this shift type on this day would cause >maxStaff at any time
            // Exception: Allow up to 3 staff during changeover period (12:00-16:30)
            const CHANGEOVER_START = 12;
            const CHANGEOVER_END = 16.5;
            
            const newCoverage = SHIFTS[newShiftType].coverage;
            
            for (const [start, end] of newCoverage) {
                for (let t = start; t < end; t += 0.5) {
                    const currentCount = getStaffCountAtTime(day, t);
                    
                    // During changeover, allow up to 3 staff
                    const isChangeover = (t >= CHANGEOVER_START && t < CHANGEOVER_END);
                    const effectiveMax = isChangeover ? 3 : maxStaff;
                    
                    if (currentCount >= effectiveMax) {
                        return true; // Already at max, can't add more
                    }
                }
            }
            return false;
        }
        
        function setupShiftButtons() {
            document.querySelectorAll('.shift-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.shift-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectedShift = btn.dataset.shift;
                });
            });
        }
        
        function renderTable() {
            const tbody = document.getElementById('rotaBody');
            tbody.innerHTML = '';
            
            staff.forEach(s => {
                const row = document.createElement('tr');
                
                const nameCell = document.createElement('td');
                nameCell.className = 'staff-name';
                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.className = 'staff-name-input';
                nameInput.value = s.name;
                nameInput.onchange = (e) => {
                    s.name = e.target.value;
                    saveToLocalStorage();
                };
                nameCell.appendChild(nameInput);
                row.appendChild(nameCell);
                
                DAYS.forEach(day => {
                    const cell = document.createElement('td');
                    cell.className = 'shift-cell';
                    cell.dataset.staff = s.id;
                    cell.dataset.day = day;
                    
                    const shift = rota[s.id][day];
                    if (shift) {
                        if (shift === 'off') {
                            cell.classList.add('off');
                            cell.textContent = 'OFF';
                        } else {
                            cell.classList.add('has-shift');
                            cell.classList.add(shift);
                            cell.innerHTML = `<strong>${SHIFTS[shift].name}</strong><br><small>${SHIFTS[shift].time}</small>`;
                        }
                    }
                    
                    cell.addEventListener('click', () => handleCellClick(s.id, day));
                    row.appendChild(cell);
                });
                
                const hoursCell = document.createElement('td');
                hoursCell.className = 'staff-hours';
                const hours = calculateStaffHours(s.id);
                hoursCell.textContent = `${hours} / ${TARGET_HOURS}`;
                if (hours > TARGET_HOURS) {
                    hoursCell.classList.add('over');
                } else if (hours < TARGET_HOURS) {
                    hoursCell.classList.add('under');
                } else {
                    hoursCell.classList.add('exact');
                }
                row.appendChild(hoursCell);
                
                tbody.appendChild(row);
            });
            
            updateStats();
            renderTimeGrid();
            renderWeekendStats();
        }
        
        function renderTimeGrid() {
            const container = document.getElementById('coverageGraph');
            container.innerHTML = '';
            
            const maxStaff = 5;
            const barHeight = 150;
            
            DAYS.forEach((day, dayIdx) => {
                const dayContainer = document.createElement('div');
                dayContainer.style.cssText = 'flex: 1; min-width: 120px; background: var(--card-bg); border-radius: 8px; padding: 10px; border: 1px solid var(--border-color);';
                
                const dayLabel = document.createElement('div');
                dayLabel.className = 'day-label';
                dayLabel.style.cssText = 'text-align: center; font-weight: bold; margin-bottom: 10px; color: var(--text-color);';
                dayLabel.textContent = DAY_NAMES[dayIdx];
                if (dayIdx >= 5) {
                    dayLabel.style.color = '#8e44ad';
                }
                dayContainer.appendChild(dayLabel);
                
                // Graph wrapper with Y-axis
                const graphWrapper = document.createElement('div');
                graphWrapper.style.cssText = 'display: flex; gap: 5px;';
                
                // Y-axis labels
                const yAxis = document.createElement('div');
                yAxis.className = 'y-axis';
                yAxis.style.cssText = `display: flex; flex-direction: column; justify-content: space-between; height: ${barHeight}px; font-size: 10px; color: var(--text-muted); text-align: right;`;
                for (let i = maxStaff; i >= 0; i--) {
                    const label = document.createElement('div');
                    label.textContent = i;
                    label.style.cssText = 'line-height: 1;';
                    yAxis.appendChild(label);
                }
                graphWrapper.appendChild(yAxis);
                
                const graphArea = document.createElement('div');
                graphArea.className = 'graph-area';
                graphArea.style.cssText = `display: flex; align-items: flex-end; gap: 1px; height: ${barHeight}px; background: var(--staff-row-bg); border-radius: 4px; padding: 2px; flex: 1;`;
                
                // Create bars for each 30-min slot
                const CHANGEOVER_START = 12;
                const CHANGEOVER_END = 16.5;
                
                for (let t = OPEN_TIME; t < CLOSE_TIME; t += 0.5) {
                    const count = getStaffCountAtTime(day, t);
                    const shifts = getShiftsAtTime(day, t);
                    const isChangeover = (t >= CHANGEOVER_START && t < CHANGEOVER_END);
                    
                    const bar = document.createElement('div');
                    const heightPercent = (count / maxStaff) * 100;
                    
                    let bgColor;
                    if (count === 0) {
                        bgColor = '#e74c3c'; // gap - red
                    } else if (count >= 1 && count <= 2) {
                        bgColor = '#27ae60'; // good - green (1-2 staff)
                    } else if (count === 3 && isChangeover) {
                        bgColor = '#3498db'; // acceptable during changeover - blue
                    } else {
                        bgColor = '#e67e22'; // over - orange (4+ or 3 outside changeover)
                    }
                    
                    bar.style.cssText = `flex: 1; height: ${heightPercent}%; background: ${bgColor}; border-radius: 2px 2px 0 0; min-height: ${count > 0 ? '4px' : '100%'}; transition: height 0.3s;`;
                    bar.title = `${Math.floor(t)}:${(t % 1) * 60 || '00'} - ${count} staff${isChangeover ? ' (changeover)' : ''}`;
                    
                    if (count === 0) {
                        bar.style.opacity = '0.5';
                    }
                    
                    graphArea.appendChild(bar);
                }
                
                graphWrapper.appendChild(graphArea);
                dayContainer.appendChild(graphWrapper);
                
                // Time labels
                const timeLabels = document.createElement('div');
                timeLabels.className = 'time-labels';
                timeLabels.style.cssText = 'display: flex; justify-content: space-between; font-size: 10px; color: var(--text-muted); margin-top: 5px;';
                timeLabels.innerHTML = '<span style="margin-left: 20px;">08:00</span><span>14:00</span><span>20:30</span>';
                dayContainer.appendChild(timeLabels);
                
                // Summary
                const summary = document.createElement('div');
                summary.className = 'summary';
                summary.style.cssText = 'text-align: center; margin-top: 8px; font-size: 12px;';
                
                let gaps = 0;
                for (let t = OPEN_TIME; t < CLOSE_TIME; t += 0.5) {
                    if (getStaffCountAtTime(day, t) === 0) gaps++;
                }
                
                if (gaps === 0) {
                    summary.innerHTML = '<span style="color: #27ae60; font-weight: bold;">Full Coverage</span>';
                } else {
                    summary.innerHTML = `<span style="color: #e74c3c; font-weight: bold;">${gaps * 0.5}hr gaps</span>`;
                }
                dayContainer.appendChild(summary);
                
                container.appendChild(dayContainer);
            });
        }
        
        function getShiftsAtTime(day, time) {
            let shifts = [];
            staff.forEach(s => {
                const shift = rota[s.id][day];
                if (shift && shift !== 'off') {
                    const coverage = SHIFTS[shift].coverage;
                    for (const [start, end] of coverage) {
                        if (time >= start && time < end) {
                            if (!shifts.includes(shift)) {
                                shifts.push(shift);
                            }
                            break;
                        }
                    }
                }
            });
            return shifts;
        }
        
        function getStaffCountAtTime(day, time) {
            let count = 0;
            staff.forEach(s => {
                const shift = rota[s.id][day];
                if (shift && shift !== 'off') {
                    const coverage = SHIFTS[shift].coverage;
                    for (const [start, end] of coverage) {
                        if (time >= start && time < end) {
                            count++;
                            break;
                        }
                    }
                }
            });
            return count;
        }
        
        function handleCellClick(staffId, day) {
            if (selectedShift) {
                if (selectedShift === 'off') {
                    rota[staffId][day] = 'off';
                    // Add to persistent day off patterns
                    if (!dayOffPatterns[staffId]) {
                        dayOffPatterns[staffId] = [];
                    }
                    if (!dayOffPatterns[staffId].includes(day)) {
                        dayOffPatterns[staffId].push(day);
                    }
                    saveDayOffPatterns();
                } else if (rota[staffId][day] === selectedShift) {
                    rota[staffId][day] = null;
                    // Remove from day off patterns if clearing
                    if (dayOffPatterns[staffId]) {
                        dayOffPatterns[staffId] = dayOffPatterns[staffId].filter(d => d !== day);
                        saveDayOffPatterns();
                    }
                } else {
                    rota[staffId][day] = selectedShift;
                    // Remove from day off patterns if assigning a shift
                    if (dayOffPatterns[staffId]) {
                        dayOffPatterns[staffId] = dayOffPatterns[staffId].filter(d => d !== day);
                        saveDayOffPatterns();
                    }
                }
                saveToLocalStorage();
                renderTable();
            }
        }
        
        function calculateStaffHours(staffId) {
            let total = 0;
            DAYS.forEach(day => {
                const shift = rota[staffId][day];
                if (shift && shift !== 'off') {
                    total += SHIFTS[shift].hours;
                }
            });
            return total;
        }
        
        function hasFullCoverage(day) {
            for (let t = OPEN_TIME; t < CLOSE_TIME; t += 0.5) {
                if (getStaffCountAtTime(day, t) === 0) {
                    return false;
                }
            }
            return true;
        }
        
        function updateStats() {
            let totalHours = 0;
            let allCovered = true;
            
            staff.forEach(s => {
                totalHours += calculateStaffHours(s.id);
            });
            
            DAYS.forEach(day => {
                if (!hasFullCoverage(day)) {
                    allCovered = false;
                }
            });
            
            const totalEl = document.getElementById('totalHours');
            totalEl.textContent = `${totalHours} hrs`;
            totalEl.className = totalHours > TARGET_HOURS * 5 ? 'error' : 
                               totalHours < TARGET_HOURS * 5 ? 'warning' : 'success';
            
            const statusEl = document.getElementById('coverageStatus');
            if (allCovered) {
                statusEl.textContent = 'Full coverage!';
                statusEl.className = 'success';
            } else {
                statusEl.textContent = 'GAPS in coverage';
                statusEl.className = 'error';
            }
        }
        
        function clearAll() {
            if (confirm('Clear all shifts?')) {
                staff.forEach(s => {
                    DAYS.forEach(day => {
                        rota[s.id][day] = null;
                    });
                });
                saveToLocalStorage();
                renderTable();
            }
        }
        
        function autoFill() {
            // Try to fill coverage gaps
            DAYS.forEach(day => {
                // Check each time slot
                for (let t = OPEN_TIME; t < CLOSE_TIME; t += 0.5) {
                    if (getStaffCountAtTime(day, t) === 0) {
                        // Find a staff member who can cover this time
                        for (const s of staff) {
                            const currentHours = calculateStaffHours(s.id);
                            const currentShift = rota[s.id][day];
                            
                            if (!currentShift && currentHours < TARGET_HOURS) {
                                // Determine best shift based on gap time
                                if (t < 12) {
                                    rota[s.id][day] = 'early';
                                } else if (t >= 16) {
                                    rota[s.id][day] = 'late';
                                } else {
                                    rota[s.id][day] = 'mid';
                                }
                                break;
                            }
                        }
                    }
                }
            });
            
            saveToLocalStorage();
            renderTable();
        }
        
        function printRota() {
            // Set print header content (week at top)
            document.getElementById('printWeek').textContent = `Week: ${formatWeekDisplay(currentWeekStart)}`;
            
            // Set print footer content (timestamp at bottom)
            const now = new Date();
            document.getElementById('printDate').textContent = `Printed: ${now.toLocaleDateString('en-GB')} at ${now.toLocaleTimeString('en-GB', {hour: '2-digit', minute: '2-digit'})}`;
            
            // Create custom dialog
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 9999;';
            
            const dialog = document.createElement('div');
            dialog.style.cssText = 'background: var(--card-bg); padding: 20px 30px; border-radius: 8px; text-align: center; color: var(--text-color); box-shadow: 0 4px 20px rgba(0,0,0,0.3);';
            dialog.innerHTML = `
                <p style="margin: 0 0 20px; font-size: 16px;">Include hourly coverage graph in printout?</p>
                <button id="printYes" style="padding: 8px 20px; margin-right: 10px; background: #27ae60; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">Yes</button>
                <button id="printNo" style="padding: 8px 20px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">No</button>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            document.getElementById('printYes').onclick = () => {
                document.body.removeChild(overlay);
                document.querySelector('.coverage-detail').classList.add('print-visible');
                window.print();
            };
            
            document.getElementById('printNo').onclick = () => {
                document.body.removeChild(overlay);
                document.querySelector('.coverage-detail').classList.remove('print-visible');
                window.print();
            };
        }
        
        function toggleDarkMode() {
            const html = document.documentElement;
            const isDark = html.getAttribute('data-theme') === 'dark';
            
            if (isDark) {
                html.removeAttribute('data-theme');
                localStorage.setItem('darkMode', 'false');
                document.getElementById('darkModeToggle').textContent = 'Dark Mode';
            } else {
                html.setAttribute('data-theme', 'dark');
                localStorage.setItem('darkMode', 'true');
                document.getElementById('darkModeToggle').textContent = 'Light Mode';
            }
        }
        
        function loadDarkModePreference() {
            const darkMode = localStorage.getItem('darkMode');
            if (darkMode === 'true') {
                document.documentElement.setAttribute('data-theme', 'dark');
                document.getElementById('darkModeToggle').textContent = 'Light Mode';
            }
        }
        
        // Initialize
        loadDarkModePreference();
        init();
    </script>
</body>
</html>
